// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0
// source: proto/code_aster.proto

package _go

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CodeAster_Init_FullMethodName                           = "/code_aster/init"
	CodeAster_StreamLog_FullMethodName                      = "/code_aster/StreamLog"
	CodeAster_Mesh_FullMethodName                           = "/code_aster/Mesh"
	CodeAster_Model_FullMethodName                          = "/code_aster/Model"
	CodeAster_MaterialField_FullMethodName                  = "/code_aster/MaterialField"
	CodeAster_ImposedDisplacementReal_FullMethodName        = "/code_aster/ImposedDisplacementReal"
	CodeAster_DistributedPressureReal_FullMethodName        = "/code_aster/DistributedPressureReal"
	CodeAster_PhysicalProblem_FullMethodName                = "/code_aster/PhysicalProblem"
	CodeAster_DiscreteComputation_FullMethodName            = "/code_aster/DiscreteComputation"
	CodeAster_DOFNumbering_FullMethodName                   = "/code_aster/DOFNumbering"
	CodeAster_AssemblyMatrixDisplacementReal_FullMethodName = "/code_aster/AssemblyMatrixDisplacementReal"
	CodeAster_MumpsSolver_FullMethodName                    = "/code_aster/MumpsSolver"
	CodeAster_SimpleFieldOnNodesReal_FullMethodName         = "/code_aster/SimpleFieldOnNodesReal"
)

// CodeAsterClient is the client API for CodeAster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CodeAsterClient interface {
	Init(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	StreamLog(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error)
	// Return the wrapper around the Mesh service
	Mesh(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Return the wrapper around the Model service
	Model(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Return the wrapper around the MaterialField service
	MaterialField(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Return the wrapper around the ImposedDisplacementReal service
	ImposedDisplacementReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MechanicalLoadReal, error)
	// Return the wrapper around the DistributedPressureReal service
	DistributedPressureReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MechanicalLoadReal, error)
	// Return the wrapper around the PhysicalProblem service
	PhysicalProblem(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Return the wrapper around the DiscreteComputation service
	DiscreteComputation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Return the wrapper around the DOFNumbering service
	DOFNumbering(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Return the wrapper around the AssemblyMatrixDisplacementReal service
	AssemblyMatrixDisplacementReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Return the wrapper around the MumpsSolver service
	MumpsSolver(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// TODO: after this Not implemented yet
	// Return the wrapper around the SimpleFieldOnNodesReal service
	SimpleFieldOnNodesReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type codeAsterClient struct {
	cc grpc.ClientConnInterface
}

func NewCodeAsterClient(cc grpc.ClientConnInterface) CodeAsterClient {
	return &codeAsterClient{cc}
}

func (c *codeAsterClient) Init(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_Init_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) StreamLog(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CodeAster_ServiceDesc.Streams[0], CodeAster_StreamLog_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, LogLine]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CodeAster_StreamLogClient = grpc.ServerStreamingClient[LogLine]

func (c *codeAsterClient) Mesh(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_Mesh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) Model(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_Model_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) MaterialField(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_MaterialField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) ImposedDisplacementReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MechanicalLoadReal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MechanicalLoadReal)
	err := c.cc.Invoke(ctx, CodeAster_ImposedDisplacementReal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) DistributedPressureReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MechanicalLoadReal, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MechanicalLoadReal)
	err := c.cc.Invoke(ctx, CodeAster_DistributedPressureReal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) PhysicalProblem(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_PhysicalProblem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) DiscreteComputation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_DiscreteComputation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) DOFNumbering(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_DOFNumbering_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) AssemblyMatrixDisplacementReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_AssemblyMatrixDisplacementReal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) MumpsSolver(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_MumpsSolver_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *codeAsterClient) SimpleFieldOnNodesReal(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CodeAster_SimpleFieldOnNodesReal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CodeAsterServer is the server API for CodeAster service.
// All implementations must embed UnimplementedCodeAsterServer
// for forward compatibility.
type CodeAsterServer interface {
	Init(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	StreamLog(*emptypb.Empty, grpc.ServerStreamingServer[LogLine]) error
	// Return the wrapper around the Mesh service
	Mesh(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Return the wrapper around the Model service
	Model(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Return the wrapper around the MaterialField service
	MaterialField(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Return the wrapper around the ImposedDisplacementReal service
	ImposedDisplacementReal(context.Context, *emptypb.Empty) (*MechanicalLoadReal, error)
	// Return the wrapper around the DistributedPressureReal service
	DistributedPressureReal(context.Context, *emptypb.Empty) (*MechanicalLoadReal, error)
	// Return the wrapper around the PhysicalProblem service
	PhysicalProblem(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Return the wrapper around the DiscreteComputation service
	DiscreteComputation(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Return the wrapper around the DOFNumbering service
	DOFNumbering(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Return the wrapper around the AssemblyMatrixDisplacementReal service
	AssemblyMatrixDisplacementReal(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Return the wrapper around the MumpsSolver service
	MumpsSolver(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// TODO: after this Not implemented yet
	// Return the wrapper around the SimpleFieldOnNodesReal service
	SimpleFieldOnNodesReal(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedCodeAsterServer()
}

// UnimplementedCodeAsterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCodeAsterServer struct{}

func (UnimplementedCodeAsterServer) Init(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedCodeAsterServer) StreamLog(*emptypb.Empty, grpc.ServerStreamingServer[LogLine]) error {
	return status.Errorf(codes.Unimplemented, "method StreamLog not implemented")
}
func (UnimplementedCodeAsterServer) Mesh(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Mesh not implemented")
}
func (UnimplementedCodeAsterServer) Model(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Model not implemented")
}
func (UnimplementedCodeAsterServer) MaterialField(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MaterialField not implemented")
}
func (UnimplementedCodeAsterServer) ImposedDisplacementReal(context.Context, *emptypb.Empty) (*MechanicalLoadReal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImposedDisplacementReal not implemented")
}
func (UnimplementedCodeAsterServer) DistributedPressureReal(context.Context, *emptypb.Empty) (*MechanicalLoadReal, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DistributedPressureReal not implemented")
}
func (UnimplementedCodeAsterServer) PhysicalProblem(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PhysicalProblem not implemented")
}
func (UnimplementedCodeAsterServer) DiscreteComputation(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscreteComputation not implemented")
}
func (UnimplementedCodeAsterServer) DOFNumbering(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DOFNumbering not implemented")
}
func (UnimplementedCodeAsterServer) AssemblyMatrixDisplacementReal(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssemblyMatrixDisplacementReal not implemented")
}
func (UnimplementedCodeAsterServer) MumpsSolver(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MumpsSolver not implemented")
}
func (UnimplementedCodeAsterServer) SimpleFieldOnNodesReal(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimpleFieldOnNodesReal not implemented")
}
func (UnimplementedCodeAsterServer) mustEmbedUnimplementedCodeAsterServer() {}
func (UnimplementedCodeAsterServer) testEmbeddedByValue()                   {}

// UnsafeCodeAsterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CodeAsterServer will
// result in compilation errors.
type UnsafeCodeAsterServer interface {
	mustEmbedUnimplementedCodeAsterServer()
}

func RegisterCodeAsterServer(s grpc.ServiceRegistrar, srv CodeAsterServer) {
	// If the following call pancis, it indicates UnimplementedCodeAsterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CodeAster_ServiceDesc, srv)
}

func _CodeAster_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_Init_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).Init(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_StreamLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CodeAsterServer).StreamLog(m, &grpc.GenericServerStream[emptypb.Empty, LogLine]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type CodeAster_StreamLogServer = grpc.ServerStreamingServer[LogLine]

func _CodeAster_Mesh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).Mesh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_Mesh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).Mesh(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_Model_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).Model(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_Model_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).Model(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_MaterialField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).MaterialField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_MaterialField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).MaterialField(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_ImposedDisplacementReal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).ImposedDisplacementReal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_ImposedDisplacementReal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).ImposedDisplacementReal(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_DistributedPressureReal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).DistributedPressureReal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_DistributedPressureReal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).DistributedPressureReal(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_PhysicalProblem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).PhysicalProblem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_PhysicalProblem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).PhysicalProblem(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_DiscreteComputation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).DiscreteComputation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_DiscreteComputation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).DiscreteComputation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_DOFNumbering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).DOFNumbering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_DOFNumbering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).DOFNumbering(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_AssemblyMatrixDisplacementReal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).AssemblyMatrixDisplacementReal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_AssemblyMatrixDisplacementReal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).AssemblyMatrixDisplacementReal(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_MumpsSolver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).MumpsSolver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_MumpsSolver_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).MumpsSolver(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _CodeAster_SimpleFieldOnNodesReal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CodeAsterServer).SimpleFieldOnNodesReal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CodeAster_SimpleFieldOnNodesReal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CodeAsterServer).SimpleFieldOnNodesReal(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CodeAster_ServiceDesc is the grpc.ServiceDesc for CodeAster service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CodeAster_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "code_aster",
	HandlerType: (*CodeAsterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "init",
			Handler:    _CodeAster_Init_Handler,
		},
		{
			MethodName: "Mesh",
			Handler:    _CodeAster_Mesh_Handler,
		},
		{
			MethodName: "Model",
			Handler:    _CodeAster_Model_Handler,
		},
		{
			MethodName: "MaterialField",
			Handler:    _CodeAster_MaterialField_Handler,
		},
		{
			MethodName: "ImposedDisplacementReal",
			Handler:    _CodeAster_ImposedDisplacementReal_Handler,
		},
		{
			MethodName: "DistributedPressureReal",
			Handler:    _CodeAster_DistributedPressureReal_Handler,
		},
		{
			MethodName: "PhysicalProblem",
			Handler:    _CodeAster_PhysicalProblem_Handler,
		},
		{
			MethodName: "DiscreteComputation",
			Handler:    _CodeAster_DiscreteComputation_Handler,
		},
		{
			MethodName: "DOFNumbering",
			Handler:    _CodeAster_DOFNumbering_Handler,
		},
		{
			MethodName: "AssemblyMatrixDisplacementReal",
			Handler:    _CodeAster_AssemblyMatrixDisplacementReal_Handler,
		},
		{
			MethodName: "MumpsSolver",
			Handler:    _CodeAster_MumpsSolver_Handler,
		},
		{
			MethodName: "SimpleFieldOnNodesReal",
			Handler:    _CodeAster_SimpleFieldOnNodesReal_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLog",
			Handler:       _CodeAster_StreamLog_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/code_aster.proto",
}

const (
	Mesh_ReadMedFile_FullMethodName = "/Mesh/readMedFile"
)

// MeshClient is the client API for Mesh service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MeshClient interface {
	ReadMedFile(ctx context.Context, in *MedFile, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type meshClient struct {
	cc grpc.ClientConnInterface
}

func NewMeshClient(cc grpc.ClientConnInterface) MeshClient {
	return &meshClient{cc}
}

func (c *meshClient) ReadMedFile(ctx context.Context, in *MedFile, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Mesh_ReadMedFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MeshServer is the server API for Mesh service.
// All implementations must embed UnimplementedMeshServer
// for forward compatibility.
type MeshServer interface {
	ReadMedFile(context.Context, *MedFile) (*emptypb.Empty, error)
	mustEmbedUnimplementedMeshServer()
}

// UnimplementedMeshServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMeshServer struct{}

func (UnimplementedMeshServer) ReadMedFile(context.Context, *MedFile) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadMedFile not implemented")
}
func (UnimplementedMeshServer) mustEmbedUnimplementedMeshServer() {}
func (UnimplementedMeshServer) testEmbeddedByValue()              {}

// UnsafeMeshServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MeshServer will
// result in compilation errors.
type UnsafeMeshServer interface {
	mustEmbedUnimplementedMeshServer()
}

func RegisterMeshServer(s grpc.ServiceRegistrar, srv MeshServer) {
	// If the following call pancis, it indicates UnimplementedMeshServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mesh_ServiceDesc, srv)
}

func _Mesh_ReadMedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MedFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MeshServer).ReadMedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mesh_ReadMedFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MeshServer).ReadMedFile(ctx, req.(*MedFile))
	}
	return interceptor(ctx, in, info, handler)
}

// Mesh_ServiceDesc is the grpc.ServiceDesc for Mesh service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mesh_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Mesh",
	HandlerType: (*MeshServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "readMedFile",
			Handler:    _Mesh_ReadMedFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	Model_AddModelingOnMesh_FullMethodName = "/Model/addModelingOnMesh"
	Model_Build_FullMethodName             = "/Model/build"
)

// ModelClient is the client API for Model service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModelClient interface {
	AddModelingOnMesh(ctx context.Context, in *Modeling, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Build(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type modelClient struct {
	cc grpc.ClientConnInterface
}

func NewModelClient(cc grpc.ClientConnInterface) ModelClient {
	return &modelClient{cc}
}

func (c *modelClient) AddModelingOnMesh(ctx context.Context, in *Modeling, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Model_AddModelingOnMesh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *modelClient) Build(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Model_Build_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModelServer is the server API for Model service.
// All implementations must embed UnimplementedModelServer
// for forward compatibility.
type ModelServer interface {
	AddModelingOnMesh(context.Context, *Modeling) (*emptypb.Empty, error)
	Build(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedModelServer()
}

// UnimplementedModelServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedModelServer struct{}

func (UnimplementedModelServer) AddModelingOnMesh(context.Context, *Modeling) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddModelingOnMesh not implemented")
}
func (UnimplementedModelServer) Build(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedModelServer) mustEmbedUnimplementedModelServer() {}
func (UnimplementedModelServer) testEmbeddedByValue()               {}

// UnsafeModelServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModelServer will
// result in compilation errors.
type UnsafeModelServer interface {
	mustEmbedUnimplementedModelServer()
}

func RegisterModelServer(s grpc.ServiceRegistrar, srv ModelServer) {
	// If the following call pancis, it indicates UnimplementedModelServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Model_ServiceDesc, srv)
}

func _Model_AddModelingOnMesh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Modeling)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).AddModelingOnMesh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_AddModelingOnMesh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).AddModelingOnMesh(ctx, req.(*Modeling))
	}
	return interceptor(ctx, in, info, handler)
}

func _Model_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModelServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Model_Build_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModelServer).Build(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Model_ServiceDesc is the grpc.ServiceDesc for Model service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Model_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Model",
	HandlerType: (*ModelServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addModelingOnMesh",
			Handler:    _Model_AddModelingOnMesh_Handler,
		},
		{
			MethodName: "build",
			Handler:    _Model_Build_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	MaterialField_AddMaterialOnMesh_FullMethodName = "/MaterialField/addMaterialOnMesh"
	MaterialField_Build_FullMethodName             = "/MaterialField/build"
)

// MaterialFieldClient is the client API for MaterialField service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MaterialFieldClient interface {
	AddMaterialOnMesh(ctx context.Context, in *Material, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// TODO: make this rpc
	// rpc addMaterialOnGroupOfCells(Material) returns (google.protobuf.Empty) {}
	Build(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type materialFieldClient struct {
	cc grpc.ClientConnInterface
}

func NewMaterialFieldClient(cc grpc.ClientConnInterface) MaterialFieldClient {
	return &materialFieldClient{cc}
}

func (c *materialFieldClient) AddMaterialOnMesh(ctx context.Context, in *Material, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MaterialField_AddMaterialOnMesh_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *materialFieldClient) Build(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MaterialField_Build_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MaterialFieldServer is the server API for MaterialField service.
// All implementations must embed UnimplementedMaterialFieldServer
// for forward compatibility.
type MaterialFieldServer interface {
	AddMaterialOnMesh(context.Context, *Material) (*emptypb.Empty, error)
	// TODO: make this rpc
	// rpc addMaterialOnGroupOfCells(Material) returns (google.protobuf.Empty) {}
	Build(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedMaterialFieldServer()
}

// UnimplementedMaterialFieldServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMaterialFieldServer struct{}

func (UnimplementedMaterialFieldServer) AddMaterialOnMesh(context.Context, *Material) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMaterialOnMesh not implemented")
}
func (UnimplementedMaterialFieldServer) Build(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedMaterialFieldServer) mustEmbedUnimplementedMaterialFieldServer() {}
func (UnimplementedMaterialFieldServer) testEmbeddedByValue()                       {}

// UnsafeMaterialFieldServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MaterialFieldServer will
// result in compilation errors.
type UnsafeMaterialFieldServer interface {
	mustEmbedUnimplementedMaterialFieldServer()
}

func RegisterMaterialFieldServer(s grpc.ServiceRegistrar, srv MaterialFieldServer) {
	// If the following call pancis, it indicates UnimplementedMaterialFieldServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MaterialField_ServiceDesc, srv)
}

func _MaterialField_AddMaterialOnMesh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Material)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaterialFieldServer).AddMaterialOnMesh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaterialField_AddMaterialOnMesh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaterialFieldServer).AddMaterialOnMesh(ctx, req.(*Material))
	}
	return interceptor(ctx, in, info, handler)
}

func _MaterialField_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MaterialFieldServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MaterialField_Build_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MaterialFieldServer).Build(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// MaterialField_ServiceDesc is the grpc.ServiceDesc for MaterialField service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MaterialField_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "MaterialField",
	HandlerType: (*MaterialFieldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addMaterialOnMesh",
			Handler:    _MaterialField_AddMaterialOnMesh_Handler,
		},
		{
			MethodName: "build",
			Handler:    _MaterialField_Build_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	ImposedDisplacementReal_SetValue_FullMethodName = "/ImposedDisplacementReal/setValue"
	ImposedDisplacementReal_Build_FullMethodName    = "/ImposedDisplacementReal/build"
)

// ImposedDisplacementRealClient is the client API for ImposedDisplacementReal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImposedDisplacementRealClient interface {
	SetValue(ctx context.Context, in *DisplacementRealWithLoadId, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Build(ctx context.Context, in *MechanicalLoadReal, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type imposedDisplacementRealClient struct {
	cc grpc.ClientConnInterface
}

func NewImposedDisplacementRealClient(cc grpc.ClientConnInterface) ImposedDisplacementRealClient {
	return &imposedDisplacementRealClient{cc}
}

func (c *imposedDisplacementRealClient) SetValue(ctx context.Context, in *DisplacementRealWithLoadId, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ImposedDisplacementReal_SetValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imposedDisplacementRealClient) Build(ctx context.Context, in *MechanicalLoadReal, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ImposedDisplacementReal_Build_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImposedDisplacementRealServer is the server API for ImposedDisplacementReal service.
// All implementations must embed UnimplementedImposedDisplacementRealServer
// for forward compatibility.
type ImposedDisplacementRealServer interface {
	SetValue(context.Context, *DisplacementRealWithLoadId) (*emptypb.Empty, error)
	Build(context.Context, *MechanicalLoadReal) (*emptypb.Empty, error)
	mustEmbedUnimplementedImposedDisplacementRealServer()
}

// UnimplementedImposedDisplacementRealServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImposedDisplacementRealServer struct{}

func (UnimplementedImposedDisplacementRealServer) SetValue(context.Context, *DisplacementRealWithLoadId) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetValue not implemented")
}
func (UnimplementedImposedDisplacementRealServer) Build(context.Context, *MechanicalLoadReal) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedImposedDisplacementRealServer) mustEmbedUnimplementedImposedDisplacementRealServer() {
}
func (UnimplementedImposedDisplacementRealServer) testEmbeddedByValue() {}

// UnsafeImposedDisplacementRealServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImposedDisplacementRealServer will
// result in compilation errors.
type UnsafeImposedDisplacementRealServer interface {
	mustEmbedUnimplementedImposedDisplacementRealServer()
}

func RegisterImposedDisplacementRealServer(s grpc.ServiceRegistrar, srv ImposedDisplacementRealServer) {
	// If the following call pancis, it indicates UnimplementedImposedDisplacementRealServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ImposedDisplacementReal_ServiceDesc, srv)
}

func _ImposedDisplacementReal_SetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisplacementRealWithLoadId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImposedDisplacementRealServer).SetValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImposedDisplacementReal_SetValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImposedDisplacementRealServer).SetValue(ctx, req.(*DisplacementRealWithLoadId))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImposedDisplacementReal_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MechanicalLoadReal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImposedDisplacementRealServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImposedDisplacementReal_Build_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImposedDisplacementRealServer).Build(ctx, req.(*MechanicalLoadReal))
	}
	return interceptor(ctx, in, info, handler)
}

// ImposedDisplacementReal_ServiceDesc is the grpc.ServiceDesc for ImposedDisplacementReal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImposedDisplacementReal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ImposedDisplacementReal",
	HandlerType: (*ImposedDisplacementRealServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setValue",
			Handler:    _ImposedDisplacementReal_SetValue_Handler,
		},
		{
			MethodName: "build",
			Handler:    _ImposedDisplacementReal_Build_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	DistributedPressureReal_SetValue_FullMethodName = "/DistributedPressureReal/setValue"
	DistributedPressureReal_Build_FullMethodName    = "/DistributedPressureReal/build"
)

// DistributedPressureRealClient is the client API for DistributedPressureReal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DistributedPressureRealClient interface {
	SetValue(ctx context.Context, in *PressureRealWithLoadId, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Build(ctx context.Context, in *MechanicalLoadReal, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type distributedPressureRealClient struct {
	cc grpc.ClientConnInterface
}

func NewDistributedPressureRealClient(cc grpc.ClientConnInterface) DistributedPressureRealClient {
	return &distributedPressureRealClient{cc}
}

func (c *distributedPressureRealClient) SetValue(ctx context.Context, in *PressureRealWithLoadId, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DistributedPressureReal_SetValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *distributedPressureRealClient) Build(ctx context.Context, in *MechanicalLoadReal, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DistributedPressureReal_Build_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DistributedPressureRealServer is the server API for DistributedPressureReal service.
// All implementations must embed UnimplementedDistributedPressureRealServer
// for forward compatibility.
type DistributedPressureRealServer interface {
	SetValue(context.Context, *PressureRealWithLoadId) (*emptypb.Empty, error)
	Build(context.Context, *MechanicalLoadReal) (*emptypb.Empty, error)
	mustEmbedUnimplementedDistributedPressureRealServer()
}

// UnimplementedDistributedPressureRealServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDistributedPressureRealServer struct{}

func (UnimplementedDistributedPressureRealServer) SetValue(context.Context, *PressureRealWithLoadId) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetValue not implemented")
}
func (UnimplementedDistributedPressureRealServer) Build(context.Context, *MechanicalLoadReal) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Build not implemented")
}
func (UnimplementedDistributedPressureRealServer) mustEmbedUnimplementedDistributedPressureRealServer() {
}
func (UnimplementedDistributedPressureRealServer) testEmbeddedByValue() {}

// UnsafeDistributedPressureRealServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DistributedPressureRealServer will
// result in compilation errors.
type UnsafeDistributedPressureRealServer interface {
	mustEmbedUnimplementedDistributedPressureRealServer()
}

func RegisterDistributedPressureRealServer(s grpc.ServiceRegistrar, srv DistributedPressureRealServer) {
	// If the following call pancis, it indicates UnimplementedDistributedPressureRealServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DistributedPressureReal_ServiceDesc, srv)
}

func _DistributedPressureReal_SetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PressureRealWithLoadId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedPressureRealServer).SetValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedPressureReal_SetValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedPressureRealServer).SetValue(ctx, req.(*PressureRealWithLoadId))
	}
	return interceptor(ctx, in, info, handler)
}

func _DistributedPressureReal_Build_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MechanicalLoadReal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DistributedPressureRealServer).Build(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DistributedPressureReal_Build_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DistributedPressureRealServer).Build(ctx, req.(*MechanicalLoadReal))
	}
	return interceptor(ctx, in, info, handler)
}

// DistributedPressureReal_ServiceDesc is the grpc.ServiceDesc for DistributedPressureReal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DistributedPressureReal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "DistributedPressureReal",
	HandlerType: (*DistributedPressureRealServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "setValue",
			Handler:    _DistributedPressureReal_SetValue_Handler,
		},
		{
			MethodName: "build",
			Handler:    _DistributedPressureReal_Build_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	PhysicalProblem_AddLoad_FullMethodName             = "/PhysicalProblem/addLoad"
	PhysicalProblem_ComputeDOFNumbering_FullMethodName = "/PhysicalProblem/computeDOFNumbering"
)

// PhysicalProblemClient is the client API for PhysicalProblem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PhysicalProblemClient interface {
	AddLoad(ctx context.Context, in *MechanicalLoadReal, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ComputeDOFNumbering(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type physicalProblemClient struct {
	cc grpc.ClientConnInterface
}

func NewPhysicalProblemClient(cc grpc.ClientConnInterface) PhysicalProblemClient {
	return &physicalProblemClient{cc}
}

func (c *physicalProblemClient) AddLoad(ctx context.Context, in *MechanicalLoadReal, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PhysicalProblem_AddLoad_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *physicalProblemClient) ComputeDOFNumbering(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PhysicalProblem_ComputeDOFNumbering_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PhysicalProblemServer is the server API for PhysicalProblem service.
// All implementations must embed UnimplementedPhysicalProblemServer
// for forward compatibility.
type PhysicalProblemServer interface {
	AddLoad(context.Context, *MechanicalLoadReal) (*emptypb.Empty, error)
	ComputeDOFNumbering(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedPhysicalProblemServer()
}

// UnimplementedPhysicalProblemServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPhysicalProblemServer struct{}

func (UnimplementedPhysicalProblemServer) AddLoad(context.Context, *MechanicalLoadReal) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLoad not implemented")
}
func (UnimplementedPhysicalProblemServer) ComputeDOFNumbering(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComputeDOFNumbering not implemented")
}
func (UnimplementedPhysicalProblemServer) mustEmbedUnimplementedPhysicalProblemServer() {}
func (UnimplementedPhysicalProblemServer) testEmbeddedByValue()                         {}

// UnsafePhysicalProblemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PhysicalProblemServer will
// result in compilation errors.
type UnsafePhysicalProblemServer interface {
	mustEmbedUnimplementedPhysicalProblemServer()
}

func RegisterPhysicalProblemServer(s grpc.ServiceRegistrar, srv PhysicalProblemServer) {
	// If the following call pancis, it indicates UnimplementedPhysicalProblemServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PhysicalProblem_ServiceDesc, srv)
}

func _PhysicalProblem_AddLoad_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MechanicalLoadReal)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PhysicalProblemServer).AddLoad(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PhysicalProblem_AddLoad_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PhysicalProblemServer).AddLoad(ctx, req.(*MechanicalLoadReal))
	}
	return interceptor(ctx, in, info, handler)
}

func _PhysicalProblem_ComputeDOFNumbering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PhysicalProblemServer).ComputeDOFNumbering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PhysicalProblem_ComputeDOFNumbering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PhysicalProblemServer).ComputeDOFNumbering(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// PhysicalProblem_ServiceDesc is the grpc.ServiceDesc for PhysicalProblem service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PhysicalProblem_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "PhysicalProblem",
	HandlerType: (*PhysicalProblemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addLoad",
			Handler:    _PhysicalProblem_AddLoad_Handler,
		},
		{
			MethodName: "computeDOFNumbering",
			Handler:    _PhysicalProblem_ComputeDOFNumbering_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	DiscreteComputation_GetNeumannForces_FullMethodName         = "/DiscreteComputation/getNeumannForces"
	DiscreteComputation_GetLinearStiffnessMatrix_FullMethodName = "/DiscreteComputation/getLinearStiffnessMatrix"
	DiscreteComputation_GetDualStiffnessMatrix_FullMethodName   = "/DiscreteComputation/getDualStiffnessMatrix"
)

// DiscreteComputationClient is the client API for DiscreteComputation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiscreteComputationClient interface {
	GetNeumannForces(ctx context.Context, in *NeumannForcesParams, opts ...grpc.CallOption) (*FieldOnNodesId, error)
	GetLinearStiffnessMatrix(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ElementaryMatrix, error)
	GetDualStiffnessMatrix(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ElementaryMatrix, error)
}

type discreteComputationClient struct {
	cc grpc.ClientConnInterface
}

func NewDiscreteComputationClient(cc grpc.ClientConnInterface) DiscreteComputationClient {
	return &discreteComputationClient{cc}
}

func (c *discreteComputationClient) GetNeumannForces(ctx context.Context, in *NeumannForcesParams, opts ...grpc.CallOption) (*FieldOnNodesId, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FieldOnNodesId)
	err := c.cc.Invoke(ctx, DiscreteComputation_GetNeumannForces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discreteComputationClient) GetLinearStiffnessMatrix(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ElementaryMatrix, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ElementaryMatrix)
	err := c.cc.Invoke(ctx, DiscreteComputation_GetLinearStiffnessMatrix_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discreteComputationClient) GetDualStiffnessMatrix(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ElementaryMatrix, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ElementaryMatrix)
	err := c.cc.Invoke(ctx, DiscreteComputation_GetDualStiffnessMatrix_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiscreteComputationServer is the server API for DiscreteComputation service.
// All implementations must embed UnimplementedDiscreteComputationServer
// for forward compatibility.
type DiscreteComputationServer interface {
	GetNeumannForces(context.Context, *NeumannForcesParams) (*FieldOnNodesId, error)
	GetLinearStiffnessMatrix(context.Context, *emptypb.Empty) (*ElementaryMatrix, error)
	GetDualStiffnessMatrix(context.Context, *emptypb.Empty) (*ElementaryMatrix, error)
	mustEmbedUnimplementedDiscreteComputationServer()
}

// UnimplementedDiscreteComputationServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDiscreteComputationServer struct{}

func (UnimplementedDiscreteComputationServer) GetNeumannForces(context.Context, *NeumannForcesParams) (*FieldOnNodesId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNeumannForces not implemented")
}
func (UnimplementedDiscreteComputationServer) GetLinearStiffnessMatrix(context.Context, *emptypb.Empty) (*ElementaryMatrix, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLinearStiffnessMatrix not implemented")
}
func (UnimplementedDiscreteComputationServer) GetDualStiffnessMatrix(context.Context, *emptypb.Empty) (*ElementaryMatrix, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDualStiffnessMatrix not implemented")
}
func (UnimplementedDiscreteComputationServer) mustEmbedUnimplementedDiscreteComputationServer() {}
func (UnimplementedDiscreteComputationServer) testEmbeddedByValue()                             {}

// UnsafeDiscreteComputationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiscreteComputationServer will
// result in compilation errors.
type UnsafeDiscreteComputationServer interface {
	mustEmbedUnimplementedDiscreteComputationServer()
}

func RegisterDiscreteComputationServer(s grpc.ServiceRegistrar, srv DiscreteComputationServer) {
	// If the following call pancis, it indicates UnimplementedDiscreteComputationServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DiscreteComputation_ServiceDesc, srv)
}

func _DiscreteComputation_GetNeumannForces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NeumannForcesParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscreteComputationServer).GetNeumannForces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiscreteComputation_GetNeumannForces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscreteComputationServer).GetNeumannForces(ctx, req.(*NeumannForcesParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiscreteComputation_GetLinearStiffnessMatrix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscreteComputationServer).GetLinearStiffnessMatrix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiscreteComputation_GetLinearStiffnessMatrix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscreteComputationServer).GetLinearStiffnessMatrix(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiscreteComputation_GetDualStiffnessMatrix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscreteComputationServer).GetDualStiffnessMatrix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiscreteComputation_GetDualStiffnessMatrix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscreteComputationServer).GetDualStiffnessMatrix(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// DiscreteComputation_ServiceDesc is the grpc.ServiceDesc for DiscreteComputation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DiscreteComputation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "DiscreteComputation",
	HandlerType: (*DiscreteComputationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getNeumannForces",
			Handler:    _DiscreteComputation_GetNeumannForces_Handler,
		},
		{
			MethodName: "getLinearStiffnessMatrix",
			Handler:    _DiscreteComputation_GetLinearStiffnessMatrix_Handler,
		},
		{
			MethodName: "getDualStiffnessMatrix",
			Handler:    _DiscreteComputation_GetDualStiffnessMatrix_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	DOFNumbering_ComputeNumbering_FullMethodName = "/DOFNumbering/computeNumbering"
)

// DOFNumberingClient is the client API for DOFNumbering service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DOFNumberingClient interface {
	ComputeNumbering(ctx context.Context, in *ElementaryMatrices, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type dOFNumberingClient struct {
	cc grpc.ClientConnInterface
}

func NewDOFNumberingClient(cc grpc.ClientConnInterface) DOFNumberingClient {
	return &dOFNumberingClient{cc}
}

func (c *dOFNumberingClient) ComputeNumbering(ctx context.Context, in *ElementaryMatrices, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DOFNumbering_ComputeNumbering_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DOFNumberingServer is the server API for DOFNumbering service.
// All implementations must embed UnimplementedDOFNumberingServer
// for forward compatibility.
type DOFNumberingServer interface {
	ComputeNumbering(context.Context, *ElementaryMatrices) (*emptypb.Empty, error)
	mustEmbedUnimplementedDOFNumberingServer()
}

// UnimplementedDOFNumberingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDOFNumberingServer struct{}

func (UnimplementedDOFNumberingServer) ComputeNumbering(context.Context, *ElementaryMatrices) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComputeNumbering not implemented")
}
func (UnimplementedDOFNumberingServer) mustEmbedUnimplementedDOFNumberingServer() {}
func (UnimplementedDOFNumberingServer) testEmbeddedByValue()                      {}

// UnsafeDOFNumberingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DOFNumberingServer will
// result in compilation errors.
type UnsafeDOFNumberingServer interface {
	mustEmbedUnimplementedDOFNumberingServer()
}

func RegisterDOFNumberingServer(s grpc.ServiceRegistrar, srv DOFNumberingServer) {
	// If the following call pancis, it indicates UnimplementedDOFNumberingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DOFNumbering_ServiceDesc, srv)
}

func _DOFNumbering_ComputeNumbering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementaryMatrices)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DOFNumberingServer).ComputeNumbering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DOFNumbering_ComputeNumbering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DOFNumberingServer).ComputeNumbering(ctx, req.(*ElementaryMatrices))
	}
	return interceptor(ctx, in, info, handler)
}

// DOFNumbering_ServiceDesc is the grpc.ServiceDesc for DOFNumbering service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DOFNumbering_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "DOFNumbering",
	HandlerType: (*DOFNumberingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "computeNumbering",
			Handler:    _DOFNumbering_ComputeNumbering_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	AssemblyMatrixDisplacementReal_AddElementaryMatrix_FullMethodName = "/AssemblyMatrixDisplacementReal/addElementaryMatrix"
	AssemblyMatrixDisplacementReal_SetDOFNumbering_FullMethodName     = "/AssemblyMatrixDisplacementReal/setDOFNumbering"
	AssemblyMatrixDisplacementReal_Assemble_FullMethodName            = "/AssemblyMatrixDisplacementReal/assemble"
)

// AssemblyMatrixDisplacementRealClient is the client API for AssemblyMatrixDisplacementReal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AssemblyMatrixDisplacementRealClient interface {
	AddElementaryMatrix(ctx context.Context, in *ElementaryMatrix, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetDOFNumbering(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Assemble(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type assemblyMatrixDisplacementRealClient struct {
	cc grpc.ClientConnInterface
}

func NewAssemblyMatrixDisplacementRealClient(cc grpc.ClientConnInterface) AssemblyMatrixDisplacementRealClient {
	return &assemblyMatrixDisplacementRealClient{cc}
}

func (c *assemblyMatrixDisplacementRealClient) AddElementaryMatrix(ctx context.Context, in *ElementaryMatrix, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AssemblyMatrixDisplacementReal_AddElementaryMatrix_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assemblyMatrixDisplacementRealClient) SetDOFNumbering(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AssemblyMatrixDisplacementReal_SetDOFNumbering_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *assemblyMatrixDisplacementRealClient) Assemble(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AssemblyMatrixDisplacementReal_Assemble_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AssemblyMatrixDisplacementRealServer is the server API for AssemblyMatrixDisplacementReal service.
// All implementations must embed UnimplementedAssemblyMatrixDisplacementRealServer
// for forward compatibility.
type AssemblyMatrixDisplacementRealServer interface {
	AddElementaryMatrix(context.Context, *ElementaryMatrix) (*emptypb.Empty, error)
	SetDOFNumbering(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Assemble(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedAssemblyMatrixDisplacementRealServer()
}

// UnimplementedAssemblyMatrixDisplacementRealServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAssemblyMatrixDisplacementRealServer struct{}

func (UnimplementedAssemblyMatrixDisplacementRealServer) AddElementaryMatrix(context.Context, *ElementaryMatrix) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddElementaryMatrix not implemented")
}
func (UnimplementedAssemblyMatrixDisplacementRealServer) SetDOFNumbering(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDOFNumbering not implemented")
}
func (UnimplementedAssemblyMatrixDisplacementRealServer) Assemble(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Assemble not implemented")
}
func (UnimplementedAssemblyMatrixDisplacementRealServer) mustEmbedUnimplementedAssemblyMatrixDisplacementRealServer() {
}
func (UnimplementedAssemblyMatrixDisplacementRealServer) testEmbeddedByValue() {}

// UnsafeAssemblyMatrixDisplacementRealServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AssemblyMatrixDisplacementRealServer will
// result in compilation errors.
type UnsafeAssemblyMatrixDisplacementRealServer interface {
	mustEmbedUnimplementedAssemblyMatrixDisplacementRealServer()
}

func RegisterAssemblyMatrixDisplacementRealServer(s grpc.ServiceRegistrar, srv AssemblyMatrixDisplacementRealServer) {
	// If the following call pancis, it indicates UnimplementedAssemblyMatrixDisplacementRealServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AssemblyMatrixDisplacementReal_ServiceDesc, srv)
}

func _AssemblyMatrixDisplacementReal_AddElementaryMatrix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementaryMatrix)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssemblyMatrixDisplacementRealServer).AddElementaryMatrix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssemblyMatrixDisplacementReal_AddElementaryMatrix_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssemblyMatrixDisplacementRealServer).AddElementaryMatrix(ctx, req.(*ElementaryMatrix))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssemblyMatrixDisplacementReal_SetDOFNumbering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssemblyMatrixDisplacementRealServer).SetDOFNumbering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssemblyMatrixDisplacementReal_SetDOFNumbering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssemblyMatrixDisplacementRealServer).SetDOFNumbering(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AssemblyMatrixDisplacementReal_Assemble_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AssemblyMatrixDisplacementRealServer).Assemble(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AssemblyMatrixDisplacementReal_Assemble_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AssemblyMatrixDisplacementRealServer).Assemble(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// AssemblyMatrixDisplacementReal_ServiceDesc is the grpc.ServiceDesc for AssemblyMatrixDisplacementReal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AssemblyMatrixDisplacementReal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "AssemblyMatrixDisplacementReal",
	HandlerType: (*AssemblyMatrixDisplacementRealServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addElementaryMatrix",
			Handler:    _AssemblyMatrixDisplacementReal_AddElementaryMatrix_Handler,
		},
		{
			MethodName: "setDOFNumbering",
			Handler:    _AssemblyMatrixDisplacementReal_SetDOFNumbering_Handler,
		},
		{
			MethodName: "assemble",
			Handler:    _AssemblyMatrixDisplacementReal_Assemble_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	MumpsSolver_Factorize_FullMethodName = "/MumpsSolver/factorize"
	MumpsSolver_Solve_FullMethodName     = "/MumpsSolver/solve"
)

// MumpsSolverClient is the client API for MumpsSolver service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MumpsSolverClient interface {
	Factorize(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Solve(ctx context.Context, in *FieldOnNodesId, opts ...grpc.CallOption) (*FieldOnNodesId, error)
}

type mumpsSolverClient struct {
	cc grpc.ClientConnInterface
}

func NewMumpsSolverClient(cc grpc.ClientConnInterface) MumpsSolverClient {
	return &mumpsSolverClient{cc}
}

func (c *mumpsSolverClient) Factorize(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, MumpsSolver_Factorize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mumpsSolverClient) Solve(ctx context.Context, in *FieldOnNodesId, opts ...grpc.CallOption) (*FieldOnNodesId, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FieldOnNodesId)
	err := c.cc.Invoke(ctx, MumpsSolver_Solve_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MumpsSolverServer is the server API for MumpsSolver service.
// All implementations must embed UnimplementedMumpsSolverServer
// for forward compatibility.
type MumpsSolverServer interface {
	Factorize(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Solve(context.Context, *FieldOnNodesId) (*FieldOnNodesId, error)
	mustEmbedUnimplementedMumpsSolverServer()
}

// UnimplementedMumpsSolverServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMumpsSolverServer struct{}

func (UnimplementedMumpsSolverServer) Factorize(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Factorize not implemented")
}
func (UnimplementedMumpsSolverServer) Solve(context.Context, *FieldOnNodesId) (*FieldOnNodesId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Solve not implemented")
}
func (UnimplementedMumpsSolverServer) mustEmbedUnimplementedMumpsSolverServer() {}
func (UnimplementedMumpsSolverServer) testEmbeddedByValue()                     {}

// UnsafeMumpsSolverServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MumpsSolverServer will
// result in compilation errors.
type UnsafeMumpsSolverServer interface {
	mustEmbedUnimplementedMumpsSolverServer()
}

func RegisterMumpsSolverServer(s grpc.ServiceRegistrar, srv MumpsSolverServer) {
	// If the following call pancis, it indicates UnimplementedMumpsSolverServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MumpsSolver_ServiceDesc, srv)
}

func _MumpsSolver_Factorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MumpsSolverServer).Factorize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MumpsSolver_Factorize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MumpsSolverServer).Factorize(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MumpsSolver_Solve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FieldOnNodesId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MumpsSolverServer).Solve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MumpsSolver_Solve_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MumpsSolverServer).Solve(ctx, req.(*FieldOnNodesId))
	}
	return interceptor(ctx, in, info, handler)
}

// MumpsSolver_ServiceDesc is the grpc.ServiceDesc for MumpsSolver service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MumpsSolver_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "MumpsSolver",
	HandlerType: (*MumpsSolverServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "factorize",
			Handler:    _MumpsSolver_Factorize_Handler,
		},
		{
			MethodName: "solve",
			Handler:    _MumpsSolver_Solve_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}

const (
	FieldOnNodes_PrintMedFile_FullMethodName = "/FieldOnNodes/printMedFile"
)

// FieldOnNodesClient is the client API for FieldOnNodes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FieldOnNodesClient interface {
	PrintMedFile(ctx context.Context, in *FieldOnNodesId, opts ...grpc.CallOption) (*MedFile, error)
}

type fieldOnNodesClient struct {
	cc grpc.ClientConnInterface
}

func NewFieldOnNodesClient(cc grpc.ClientConnInterface) FieldOnNodesClient {
	return &fieldOnNodesClient{cc}
}

func (c *fieldOnNodesClient) PrintMedFile(ctx context.Context, in *FieldOnNodesId, opts ...grpc.CallOption) (*MedFile, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MedFile)
	err := c.cc.Invoke(ctx, FieldOnNodes_PrintMedFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FieldOnNodesServer is the server API for FieldOnNodes service.
// All implementations must embed UnimplementedFieldOnNodesServer
// for forward compatibility.
type FieldOnNodesServer interface {
	PrintMedFile(context.Context, *FieldOnNodesId) (*MedFile, error)
	mustEmbedUnimplementedFieldOnNodesServer()
}

// UnimplementedFieldOnNodesServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFieldOnNodesServer struct{}

func (UnimplementedFieldOnNodesServer) PrintMedFile(context.Context, *FieldOnNodesId) (*MedFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrintMedFile not implemented")
}
func (UnimplementedFieldOnNodesServer) mustEmbedUnimplementedFieldOnNodesServer() {}
func (UnimplementedFieldOnNodesServer) testEmbeddedByValue()                      {}

// UnsafeFieldOnNodesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FieldOnNodesServer will
// result in compilation errors.
type UnsafeFieldOnNodesServer interface {
	mustEmbedUnimplementedFieldOnNodesServer()
}

func RegisterFieldOnNodesServer(s grpc.ServiceRegistrar, srv FieldOnNodesServer) {
	// If the following call pancis, it indicates UnimplementedFieldOnNodesServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FieldOnNodes_ServiceDesc, srv)
}

func _FieldOnNodes_PrintMedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FieldOnNodesId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FieldOnNodesServer).PrintMedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FieldOnNodes_PrintMedFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FieldOnNodesServer).PrintMedFile(ctx, req.(*FieldOnNodesId))
	}
	return interceptor(ctx, in, info, handler)
}

// FieldOnNodes_ServiceDesc is the grpc.ServiceDesc for FieldOnNodes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FieldOnNodes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "FieldOnNodes",
	HandlerType: (*FieldOnNodesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "printMedFile",
			Handler:    _FieldOnNodes_PrintMedFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/code_aster.proto",
}
